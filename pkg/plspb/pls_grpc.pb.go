// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package plspb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// CredentialClient is the client API for Credential service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CredentialClient interface {
	// Issue creates a new token.
	//
	// If this request is authorized, a child token is created. The child token's
	// expiration may not exceed the expiration of the parent, and the child
	// token's contexts must be a subset of the parent's. When the parent token
	// is deleted, so are any children.
	Issue(ctx context.Context, in *CredentialIssueRequest, opts ...grpc.CallOption) (*CredentialIssueResponse, error)
	// Refresh reissues a token with a new expiration. The returned credential
	// may or may not reuse the same identifier as the request.
	Refresh(ctx context.Context, in *CredentialRefreshRequest, opts ...grpc.CallOption) (*CredentialRefreshResponse, error)
	// Revoke deletes a token and prevents it from being used again. Any children
	// of the token are also revoked.
	Revoke(ctx context.Context, in *CredentialRevokeRequest, opts ...grpc.CallOption) (*CredentialRevokeResponse, error)
}

type credentialClient struct {
	cc grpc.ClientConnInterface
}

func NewCredentialClient(cc grpc.ClientConnInterface) CredentialClient {
	return &credentialClient{cc}
}

var credentialIssueStreamDesc = &grpc.StreamDesc{
	StreamName: "Issue",
}

func (c *credentialClient) Issue(ctx context.Context, in *CredentialIssueRequest, opts ...grpc.CallOption) (*CredentialIssueResponse, error) {
	out := new(CredentialIssueResponse)
	err := c.cc.Invoke(ctx, "/plspb.Credential/Issue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var credentialRefreshStreamDesc = &grpc.StreamDesc{
	StreamName: "Refresh",
}

func (c *credentialClient) Refresh(ctx context.Context, in *CredentialRefreshRequest, opts ...grpc.CallOption) (*CredentialRefreshResponse, error) {
	out := new(CredentialRefreshResponse)
	err := c.cc.Invoke(ctx, "/plspb.Credential/Refresh", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var credentialRevokeStreamDesc = &grpc.StreamDesc{
	StreamName: "Revoke",
}

func (c *credentialClient) Revoke(ctx context.Context, in *CredentialRevokeRequest, opts ...grpc.CallOption) (*CredentialRevokeResponse, error) {
	out := new(CredentialRevokeResponse)
	err := c.cc.Invoke(ctx, "/plspb.Credential/Revoke", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CredentialService is the service API for Credential service.
// Fields should be assigned to their respective handler implementations only before
// RegisterCredentialService is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type CredentialService struct {
	// Issue creates a new token.
	//
	// If this request is authorized, a child token is created. The child token's
	// expiration may not exceed the expiration of the parent, and the child
	// token's contexts must be a subset of the parent's. When the parent token
	// is deleted, so are any children.
	Issue func(context.Context, *CredentialIssueRequest) (*CredentialIssueResponse, error)
	// Refresh reissues a token with a new expiration. The returned credential
	// may or may not reuse the same identifier as the request.
	Refresh func(context.Context, *CredentialRefreshRequest) (*CredentialRefreshResponse, error)
	// Revoke deletes a token and prevents it from being used again. Any children
	// of the token are also revoked.
	Revoke func(context.Context, *CredentialRevokeRequest) (*CredentialRevokeResponse, error)
}

func (s *CredentialService) issue(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CredentialIssueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.Issue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/plspb.Credential/Issue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.Issue(ctx, req.(*CredentialIssueRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CredentialService) refresh(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CredentialRefreshRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/plspb.Credential/Refresh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.Refresh(ctx, req.(*CredentialRefreshRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CredentialService) revoke(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CredentialRevokeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.Revoke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/plspb.Credential/Revoke",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.Revoke(ctx, req.(*CredentialRevokeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegisterCredentialService registers a service implementation with a gRPC server.
func RegisterCredentialService(s grpc.ServiceRegistrar, srv *CredentialService) {
	srvCopy := *srv
	if srvCopy.Issue == nil {
		srvCopy.Issue = func(context.Context, *CredentialIssueRequest) (*CredentialIssueResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method Issue not implemented")
		}
	}
	if srvCopy.Refresh == nil {
		srvCopy.Refresh = func(context.Context, *CredentialRefreshRequest) (*CredentialRefreshResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
		}
	}
	if srvCopy.Revoke == nil {
		srvCopy.Revoke = func(context.Context, *CredentialRevokeRequest) (*CredentialRevokeResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
		}
	}
	sd := grpc.ServiceDesc{
		ServiceName: "plspb.Credential",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "Issue",
				Handler:    srvCopy.issue,
			},
			{
				MethodName: "Refresh",
				Handler:    srvCopy.refresh,
			},
			{
				MethodName: "Revoke",
				Handler:    srvCopy.revoke,
			},
		},
		Streams:  []grpc.StreamDesc{},
		Metadata: "pls.proto",
	}

	s.RegisterService(&sd, nil)
}

// LogClient is the client API for Log service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogClient interface {
	// Create sets up a new log stream with a given context and name.
	Create(ctx context.Context, in *LogCreateRequest, opts ...grpc.CallOption) (*LogCreateResponse, error)
	// Delete removes access to an existing log stream. The log stream will no
	// longer be accessible to any client, although physical removal of data may
	// be delayed.
	Delete(ctx context.Context, in *LogDeleteRequest, opts ...grpc.CallOption) (*LogDeleteResponse, error)
	// List enumerates the log stream the authenticated credential has access to.
	List(ctx context.Context, in *LogListRequest, opts ...grpc.CallOption) (Log_ListClient, error)
	// MessageAppend adds a new message to the log stream. If the payload is
	// larger than 2MB, this RPC will return INVALID_ARGUMENT. If the service
	// needs to rate-limit this request, this RPC will return RESOURCE_EXHAUSTED
	// and additional information will be available in the QuotaFailure and
	// RetryInfo messages.
	MessageAppend(ctx context.Context, in *LogMessageAppendRequest, opts ...grpc.CallOption) (*LogMessageAppendResponse, error)
	// MessageList retrieves part or all of the messages in a log stream.
	// Messages are returned in the order received by the service.
	MessageList(ctx context.Context, in *LogMessageListRequest, opts ...grpc.CallOption) (Log_MessageListClient, error)
}

type logClient struct {
	cc grpc.ClientConnInterface
}

func NewLogClient(cc grpc.ClientConnInterface) LogClient {
	return &logClient{cc}
}

var logCreateStreamDesc = &grpc.StreamDesc{
	StreamName: "Create",
}

func (c *logClient) Create(ctx context.Context, in *LogCreateRequest, opts ...grpc.CallOption) (*LogCreateResponse, error) {
	out := new(LogCreateResponse)
	err := c.cc.Invoke(ctx, "/plspb.Log/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var logDeleteStreamDesc = &grpc.StreamDesc{
	StreamName: "Delete",
}

func (c *logClient) Delete(ctx context.Context, in *LogDeleteRequest, opts ...grpc.CallOption) (*LogDeleteResponse, error) {
	out := new(LogDeleteResponse)
	err := c.cc.Invoke(ctx, "/plspb.Log/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var logListStreamDesc = &grpc.StreamDesc{
	StreamName:    "List",
	ServerStreams: true,
}

func (c *logClient) List(ctx context.Context, in *LogListRequest, opts ...grpc.CallOption) (Log_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, logListStreamDesc, "/plspb.Log/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &logListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Log_ListClient interface {
	Recv() (*LogListResponse, error)
	grpc.ClientStream
}

type logListClient struct {
	grpc.ClientStream
}

func (x *logListClient) Recv() (*LogListResponse, error) {
	m := new(LogListResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var logMessageAppendStreamDesc = &grpc.StreamDesc{
	StreamName: "MessageAppend",
}

func (c *logClient) MessageAppend(ctx context.Context, in *LogMessageAppendRequest, opts ...grpc.CallOption) (*LogMessageAppendResponse, error) {
	out := new(LogMessageAppendResponse)
	err := c.cc.Invoke(ctx, "/plspb.Log/MessageAppend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var logMessageListStreamDesc = &grpc.StreamDesc{
	StreamName:    "MessageList",
	ServerStreams: true,
}

func (c *logClient) MessageList(ctx context.Context, in *LogMessageListRequest, opts ...grpc.CallOption) (Log_MessageListClient, error) {
	stream, err := c.cc.NewStream(ctx, logMessageListStreamDesc, "/plspb.Log/MessageList", opts...)
	if err != nil {
		return nil, err
	}
	x := &logMessageListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Log_MessageListClient interface {
	Recv() (*LogMessageListResponse, error)
	grpc.ClientStream
}

type logMessageListClient struct {
	grpc.ClientStream
}

func (x *logMessageListClient) Recv() (*LogMessageListResponse, error) {
	m := new(LogMessageListResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LogService is the service API for Log service.
// Fields should be assigned to their respective handler implementations only before
// RegisterLogService is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type LogService struct {
	// Create sets up a new log stream with a given context and name.
	Create func(context.Context, *LogCreateRequest) (*LogCreateResponse, error)
	// Delete removes access to an existing log stream. The log stream will no
	// longer be accessible to any client, although physical removal of data may
	// be delayed.
	Delete func(context.Context, *LogDeleteRequest) (*LogDeleteResponse, error)
	// List enumerates the log stream the authenticated credential has access to.
	List func(*LogListRequest, Log_ListServer) error
	// MessageAppend adds a new message to the log stream. If the payload is
	// larger than 2MB, this RPC will return INVALID_ARGUMENT. If the service
	// needs to rate-limit this request, this RPC will return RESOURCE_EXHAUSTED
	// and additional information will be available in the QuotaFailure and
	// RetryInfo messages.
	MessageAppend func(context.Context, *LogMessageAppendRequest) (*LogMessageAppendResponse, error)
	// MessageList retrieves part or all of the messages in a log stream.
	// Messages are returned in the order received by the service.
	MessageList func(*LogMessageListRequest, Log_MessageListServer) error
}

func (s *LogService) create(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/plspb.Log/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.Create(ctx, req.(*LogCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *LogService) delete(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/plspb.Log/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.Delete(ctx, req.(*LogDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *LogService) list(_ interface{}, stream grpc.ServerStream) error {
	m := new(LogListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return s.List(m, &logListServer{stream})
}
func (s *LogService) messageAppend(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogMessageAppendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.MessageAppend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/plspb.Log/MessageAppend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.MessageAppend(ctx, req.(*LogMessageAppendRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *LogService) messageList(_ interface{}, stream grpc.ServerStream) error {
	m := new(LogMessageListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return s.MessageList(m, &logMessageListServer{stream})
}

type Log_ListServer interface {
	Send(*LogListResponse) error
	grpc.ServerStream
}

type logListServer struct {
	grpc.ServerStream
}

func (x *logListServer) Send(m *LogListResponse) error {
	return x.ServerStream.SendMsg(m)
}

type Log_MessageListServer interface {
	Send(*LogMessageListResponse) error
	grpc.ServerStream
}

type logMessageListServer struct {
	grpc.ServerStream
}

func (x *logMessageListServer) Send(m *LogMessageListResponse) error {
	return x.ServerStream.SendMsg(m)
}

// RegisterLogService registers a service implementation with a gRPC server.
func RegisterLogService(s grpc.ServiceRegistrar, srv *LogService) {
	srvCopy := *srv
	if srvCopy.Create == nil {
		srvCopy.Create = func(context.Context, *LogCreateRequest) (*LogCreateResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
		}
	}
	if srvCopy.Delete == nil {
		srvCopy.Delete = func(context.Context, *LogDeleteRequest) (*LogDeleteResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
		}
	}
	if srvCopy.List == nil {
		srvCopy.List = func(*LogListRequest, Log_ListServer) error {
			return status.Errorf(codes.Unimplemented, "method List not implemented")
		}
	}
	if srvCopy.MessageAppend == nil {
		srvCopy.MessageAppend = func(context.Context, *LogMessageAppendRequest) (*LogMessageAppendResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method MessageAppend not implemented")
		}
	}
	if srvCopy.MessageList == nil {
		srvCopy.MessageList = func(*LogMessageListRequest, Log_MessageListServer) error {
			return status.Errorf(codes.Unimplemented, "method MessageList not implemented")
		}
	}
	sd := grpc.ServiceDesc{
		ServiceName: "plspb.Log",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "Create",
				Handler:    srvCopy.create,
			},
			{
				MethodName: "Delete",
				Handler:    srvCopy.delete,
			},
			{
				MethodName: "MessageAppend",
				Handler:    srvCopy.messageAppend,
			},
		},
		Streams: []grpc.StreamDesc{
			{
				StreamName:    "List",
				Handler:       srvCopy.list,
				ServerStreams: true,
			},
			{
				StreamName:    "MessageList",
				Handler:       srvCopy.messageList,
				ServerStreams: true,
			},
		},
		Metadata: "pls.proto",
	}

	s.RegisterService(&sd, nil)
}
